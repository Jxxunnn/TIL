function makeAdder(x) {
  var y = 1;
  return function (z) {
    y = 100;
    return x + y + z;
  };
}

var add5 = makeAdder(5);
var add10 = makeAdder(10);
//클로저에 x와 y의 환경이 저장됨

console.log(add5(2)); // 107 (x:5 + y:100 + z:2)
console.log(add10(2)); // 112 (x:10 + y:100 + z:2)
//함수 실행 시 클로저에 저장된 x, y값에 접근하여 값을 계산
//지역스코프에서 값을 찾고, 없으면 그 밖에 있는 스코프에서 찾고, 계속해서 찾아 올라가 전역 스코프까지 찾아보는 것을 스코프체이닝
//어려운 얘기로는 내부 렉시컬 환경에서 찾고 없으면 전역 렉시컬 환경에서 찾는다 얘기함.
//함수가 수행된 이후에도 상위함수의 렉시컬 환경에 접근 가능

//const arr = [ 1, 2, 3, ..., 1000000000, 1000000001]
//const num = 5

function callbyvalue(파라미터) {
  return 파라미터;
}
// 위의 경우...
// 비원시타입 데이터를 인자로 넘길 때, arr의 주소값을 참조하는게 아니라 배열값을 복제해서 넘겨주는 것 이라면
// value를 복제해서 파라미터에 넣는 과정 자체가 시간부하가 걸릴 수 있을지에 대한 질문이었는데

// 배열값을 복제해서 넘기는게 아니라 주소값을 복제해서 넘기는 것이라고 다시 이해했습니다.
// 따라서 위의 질문은 전제가 잘못되었던 것 같습니다.
